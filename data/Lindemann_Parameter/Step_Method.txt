public void step() {
      steps++;
      double dxtrial = 0, dytrial = 0, dztrial = 0, datrial = 0;
      double HertzEnergy;
      double xij, yij, zij, de, r, r2, sigma;
      double mixF, elasticF;
      double capVolForI, capVolSumBeforeMove = 0, capVolSumAfterMove = 0, capVolSumBeforeMoveI, capVolSumBeforeMoveJ;
      int i, j, k;
      double dFlory;
      double capVolForJ;
      double newSWR; // new swelling ratio
      double totalOverlapVolume = 0;
      double xjk, yjk, zjk;

      // Compute Flory-Rehner free energy for each microgel before the trial move
      for (i = 0; i < N; i++) {
         // Reset the cumulative cap volumes
         capVolSumBeforeMove = 0;
         // Calculate the volume of the fully swollen microgel
         volOfMicrogel[i] = (4.0 / 3.0) * Math.PI * Math.pow(a[i], 3);

         for (j = 0; j < N; j++) {
            if (j != i) { // consider interactions with other particles
               xij = PBC.separation(x[i] - x[j], side);
               yij = PBC.separation(y[i] - y[j], side);
               zij = PBC.separation(z[i] - z[j], side);
               r2 = xij * xij + yij * yij + zij * zij; // particle separation squared
               sigma = a[i] + a[j];
               capVolForJ = 0;

               // Check for overlap
               if (r2 < sigma * sigma) {
                  r = Math.sqrt(r2);
                  // Compute heights of the caps
                  double hi = (a[j] - a[i] + r) * (a[j] + a[i] - r) / (2.0 * r);
                  double hj = (a[i] - a[j] + r) * (a[i] + a[j] - r) / (2.0 * r);
                  // Compute cap volume
                  capVolForI = (Math.PI * Math.pow(hi, 2) * (3.0 * a[i] - hi)) / 3.0;
                  capVolForJ = (Math.PI * Math.pow(hj, 2) * (3.0 * a[j] - hj)) / 3.0;
                  capVolSumBeforeMove += capVolForI;
               }
            }
         }

         // Flory-Rehner free energy for i
         newSWR = a[i] * Math.pow(((volOfMicrogel[i]-capVolSumBeforeMove)/volOfMicrogel[i]), 1.0/3.0);
         mixF = nMon * ((newSWR*newSWR*newSWR-1)*Math.log(1-1/(newSWR*newSWR*newSWR))+chi*(1-1/(newSWR*newSWR*newSWR)));
         elasticF = 1.5 * nMon * xLinkFrac * (newSWR * newSWR - Math.log(newSWR) - 1);
         floryFRIBeforeMove = mixF + elasticF;

         for (j = 0; j < N; j++) {
            volOfMicrogel[j] = (4.0 / 3.0) * Math.PI * Math.pow(a[j], 3);
            //if (j != i) { // consider interactions with other particles
               // Reset the cumulative cap volumes for microgel j
               capVolSumBeforeMoveJ = 0;
               for (k = 0; k < N; k++) {
                  if (k != j) {
                     xjk = PBC.separation(x[j] - x[k], side);
                     yjk = PBC.separation(y[j] - y[k], side);
                     zjk = PBC.separation(z[j] - z[k], side);
                     r2 = xjk * xjk + yjk * yjk + zjk * zjk; // particle separation squared
                     sigma = a[j] + a[k];
                     // Check for overlap
                     if (r2 < sigma * sigma) {
                        r = Math.sqrt(r2);
                        // Compute heights of the caps
                        double hk = (a[k]-a[j]+r)*(a[k]+a[j]-r)/(2.0*r);
                        double hj = (a[j]-a[k]+r)*(a[j]+a[k]-r)/(2.0*r);
                        // Compute cap volume
                        capVolForJ = (Math.PI*Math.pow(hj, 2)*(3.0*a[j]-hj))/3.0;
                        capVolSumBeforeMoveJ += capVolForJ;
                     }
                  }
               }

               newSWR = a[j]*Math.pow(((volOfMicrogel[j]-capVolSumBeforeMoveJ)/volOfMicrogel[j]), 1.0/3.0);
               mixF = nMon*((newSWR*newSWR*newSWR-1)*Math.log(1-1/(newSWR*newSWR*newSWR))+chi*(1-1/(newSWR*newSWR*newSWR)));
               elasticF = 1.5*nMon*xLinkFrac*(newSWR*newSWR-Math.log(newSWR)-1);
               floryFRBeforeMove[j] = mixF + elasticF;

               //System.out.println("floryRehnerBeforeMove: " + floryFRBeforeMove[j] + " for microgel: " + j);
            //}
         }

         // Trial displacement
         dxtrial = tolerance * 2.0 * (random.nextDouble() - 0.5);
         dytrial = tolerance * 2.0 * (random.nextDouble() - 0.5);
         dztrial = tolerance * 2.0 * (random.nextDouble() - 0.5);
         datrial = atolerance * 2.0 * (random.nextDouble() - 0.5);

         x[i] += dxtrial;
         y[i] += dytrial;
         z[i] += dztrial;
         a[i] += datrial; // trial radius change

         // Reset the cumulative cap volumes after the move
         capVolSumAfterMove = 0;
         pairEnergySum = 0;
         // Calculate the volume of the fully swollen microgel i
         volOfMicrogel[i] = (4.0 / 3.0) * Math.PI * Math.pow(a[i], 3); 

         for (j = 0; j < N; j++) {
            volOfMicrogel[j] = (4.0 / 3) * Math.PI * Math.pow(a[j], 3);
            if (j != i) { // consider interactions with other particles
               xij = PBC.separation(x[i] - x[j], side);
               yij = PBC.separation(y[i] - y[j], side);
               zij = PBC.separation(z[i] - z[j], side);
               r2 = xij * xij + yij * yij + zij * zij; // particle separation squared
               sigma = a[i] + a[j];

               // Check for overlap
               if (r2 < sigma * sigma) {
                  r = Math.sqrt(r2);
                  B = scale * Young * nChains * Math.pow(sigma, 2.0) * Math.sqrt(a[i] * a[j]) / (Math.pow(a[i], 3.0) + Math.pow(a[j], 3.0));
                  HertzEnergy = B * Math.pow(1 - r / sigma, 2.5);
                  newPairEnergy[i][j] = HertzEnergy;
                  pairEnergySum += HertzEnergy;
                  //Compute heights of the caps
                  double hi = (a[j] - a[i] + r) * (a[j] + a[i] - r) / (2.0 * r);
                  double hj = (a[i] - a[j] + r) * (a[i] + a[j] - r) / (2.0 * r);
                  // Compute cap volume
                  capVolForI = (Math.PI * Math.pow(hi, 2) * (3.0 * a[i] - hi)) / 3.0;
                  capVolForJ = (Math.PI * Math.pow(hj, 2) * (3.0 * a[j] - hj)) / 3.0;
                  capVolSumAfterMove += capVolForI;
               }
            }
         }

         // Flory-Rehner free energy for i after the move
         newSWR = a[i] * Math.pow(((volOfMicrogel[i] - capVolSumAfterMove) / volOfMicrogel[i]), 1.0/3.0);
         mixF = nMon * ((newSWR * newSWR * newSWR - 1) * Math.log(1 - 1 / (newSWR * newSWR * newSWR)) + chi * (1 - 1 / (newSWR * newSWR * newSWR)));
         elasticF = 1.5 * nMon * xLinkFrac * (newSWR * newSWR - Math.log(newSWR) - 1);
         floryFRIAfterMove = mixF + elasticF;

         for (j = 0; j < N; j++) {
            //if (j != i) { // consider interactions with other particles
               // Reset the cumulative cap volumes for microgel j after the move
               double capVolSumAfterMoveJ = 0;
               for (k = 0; k < N; k++) {
                  if (k != j) {
                     xjk = PBC.separation(x[j] - x[k], side);
                     yjk = PBC.separation(y[j] - y[k], side);
                     zjk = PBC.separation(z[j] - z[k], side);
                     r2 = xjk * xjk + yjk * yjk + zjk * zjk; // particle separation squared
                     sigma = a[j] + a[k];

                     // Check for overlap
                     if (r2 < sigma * sigma) {
                        // r = Math.sqrt(r2);
                        // B = scale * Young * nChains * Math.pow(sigma, 2.0) * Math.sqrt(a[k] * a[j]) / (Math.pow(a[k], 3.0) + Math.pow(a[j], 3.0));
                        // HertzEnergy = B * Math.pow(1 - r / sigma, 2.5);
                        // newPairEnergy[i][j] = HertzEnergy;
                        // pairEnergySum += HertzEnergy;

                        r = Math.sqrt(r2);
                        // Compute heights of the caps
                        double hi = (a[k] - a[j] + r)*(a[k] + a[j] - r)/(2.0*r);
                        double hj = (a[j] - a[k] + r) * (a[j] + a[k]-r)/(2.0*r);
                        // Compute cap volume
                        capVolForJ = (Math.PI * Math.pow(hj, 2) * (3.0 * a[j] - hj)) / 3.0;
                        capVolSumAfterMoveJ += capVolForJ;
                     }
                  }
               }

               newSWR = a[j] * Math.pow(((volOfMicrogel[j] - capVolSumAfterMoveJ) / volOfMicrogel[j]), 1.0/3.0);
               mixF = nMon * ((newSWR*newSWR*newSWR-1)*Math.log(1-1/(newSWR*newSWR*newSWR))+chi*(1-1/(newSWR*newSWR*newSWR)));
               elasticF = 1.5 * nMon * xLinkFrac * (newSWR * newSWR - Math.log(newSWR) - 1);
               floryFRJAfterMove[j] = mixF + elasticF;
            //}
         }

         // Change in energy for all the microgels
         double dFloryForJ = 0;
         for (j = 0; j < N; j++) {
            dFloryForJ += (floryFRJAfterMove[j] - floryFRBeforeMove[j]);
         }

         double dFloryForI = floryFRIAfterMove - floryFRIBeforeMove;

         de = (pairEnergySum - energy[i]) + (dFloryForJ+dFloryForI);

         if (Math.exp(-de) < random.nextDouble()) { // Metropolis algorithm
            x[i] -= dxtrial; // reject move
            y[i] -= dytrial;
            z[i] -= dztrial;
            a[i] -= datrial;
         } else { // Accept move and update energies
            dxOverN += dxtrial / (double) N;
            dyOverN += dytrial / (double) N;
            dzOverN += dztrial / (double) N;
            energy[i] = pairEnergySum; // update energy of moved particle
            for (k = 0; k < N; ++k) { // update energies of other particles
               if (k != i) { // ensures that the particle i is not interacting with itself
                  energy[k] += newPairEnergy[i][k] - pairEnergy[i][k]; // For each pair of particles (i, k), it updates the energy of particle k based on the change in pair energy
                  pairEnergy[i][k] = newPairEnergy[i][k]; // updates the pair energy for the pair (i, k) with the new value calculated in the trial move
                  pairEnergy[k][i] = newPairEnergy[i][k];
               }
            }
         }
      }

      calculateTotalEnergy(lambda); // new total energy
   }







Pseudocode:

Initialize variables
    Increment steps
    Initialize trial displacement variables: dxtrial, dytrial, dztrial, datrial
    Initialize energy-related variables: HertzEnergy, de
    Initialize particle separation variables: xij, yij, zij, r, r2, sigma
    Initialize free energy variables: mixF, elasticF
    Initialize cap volume variables: capVolForI, capVolSumBeforeMove, capVolSumAfterMove, capVolSumBeforeMoveI, capVolSumBeforeMoveJ
    Initialize other necessary variables: i, j, k, dFlory, capVolForJ, newSWR, totalOverlapVolume, xjk, yjk, zjk

Compute Flory-Rehner free energy for each microgel before the trial move:
    For each microgel i:
        Reset capVolSumBeforeMove
        Calculate volume of fully swollen microgel i
        For each microgel j:
            If j is not equal to i:
                Compute separation xij, yij, zij
                Compute r2 and sigma
                Reset capVolForJ
                If overlap (r2 < sigma^2):
                    Compute heights of the caps hi, hj
                    Compute cap volumes capVolForI, capVolForJ
                    Update capVolSumBeforeMove with capVolForI
        Compute Flory-Rehner free energy for i:
            Compute newSWR for i
            Compute mixF and elasticF for i
            Compute floryFRIBeforeMove

Compute cumulative cap volumes and Flory-Rehner free energy for each microgel j:
    For each microgel j:
        If j is not equal to i:
            Reset capVolSumBeforeMoveJ
            For each microgel k:
                If k is not equal to j:
                    Compute separation xjk, yjk, zjk
                    Compute r2 and sigma
                    If overlap (r2 < sigma^2):
                        Compute heights of the caps hk, hj
                        Compute cap volume capVolForJ
                        Update capVolSumBeforeMoveJ with capVolForJ
            Compute newSWR for j
            Compute mixF and elasticF for j
            Compute floryFRBeforeMove[j]

Perform trial displacement for microgel i:
    Generate random trial displacements: dxtrial, dytrial, dztrial, datrial
    Update positions and radius of microgel i

Compute cumulative cap volumes and energies after the move:
    Reset capVolSumAfterMove and pairEnergySum
    For each microgel j:
        If j is not equal to i:
            Compute separation xij, yij, zij
            Compute r2 and sigma
            If overlap (r2 < sigma^2):
                Compute heights of the caps hi, hj
                Compute cap volumes capVolForI, capVolForJ
                Update capVolSumAfterMove with capVolForI
                Compute HertzEnergy and update pairEnergySum
    Compute newSWR for i
    Compute mixF and elasticF for i
    Compute floryFRIAfterMove

    For each microgel j:
        If j is not equal to i:
            Reset the cumulative cap volumes for microgel j after the move
            For each microgel k:
                If k is not equal to j:
                    Compute separation xjk, yjk, zjk
                    Compute r2 and sigma
                    If overlap (r2 < sigma^2):
                        Compute heights of the caps hk, hj
                        Compute cap volume capVolForJ
                        Update capVolSumAfterMoveJ with capVolForJ
            Compute newSWR for j
            Compute mixF and elasticF for j
            Compute floryFRJAfterMove[j]

Change in energy for all the microgels:
    Compute dFloryForJ
    Compute dFloryForI
    Compute de

If Metropolis algorithm condition is met:
    Reject move, revert positions and radius changes
Else:
    Accept move, update energies and displacements

Calculate total energy lambda
